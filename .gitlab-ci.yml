# ============================================================================
# Tree Navigator - Complete GitLab CI/CD Pipeline
# ============================================================================

stages:
  - lint
  - build
  - test
  - security
  - performance
  - package
  - deploy
  - monitoring

variables:
  GNAT_VERSION: "13"
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  # Disable shallow clones for better analysis
  GIT_DEPTH: 0

# ============================================================================
# Templates & Reusable Configurations
# ============================================================================

.gnat_base:
  image: ubuntu:22.04
  before_script:
    - apt-get update -qq
    - apt-get install -y -qq gnat-${GNAT_VERSION} gprbuild make file git
    - gnat --version
    - gprbuild --version

.docker_base:
  image: docker:24-dind
  services:
    - docker:24-dind
  before_script:
    - docker info

.cache_template:
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - obj/
      - .cache/

# ============================================================================
# LINT STAGE - Code Quality
# ============================================================================

lint:syntax:
  extends: 
    - .gnat_base
    - .cache_template
  stage: lint
  script:
    - echo "üîç Checking Ada syntax..."
    - |
      for file in src/*.ad[sb]; do
        echo "Checking $file..."
        gcc -c -gnat2022 -gnats "$file" || exit 1
      done
    - echo "‚úÖ Syntax check passed"
  artifacts:
    reports:
      codequality: gl-code-quality-report.json
    when: always
    expire_in: 1 week

lint:formatting:
  extends: .gnat_base
  stage: lint
  script:
    - echo "üîç Checking code formatting..."
    # Check for tabs
    - |
      if find src -name "*.ad[sb]" -exec grep -l $'\t' {} \; > tabs.txt && [ -s tabs.txt ]; then
        echo "‚ùå Files with tabs found:"
        cat tabs.txt
        exit 1
      fi
    # Check line endings
    - |
      if find src -name "*.ad[sb]" -exec file {} \; | grep CRLF; then
        echo "‚ùå CRLF line endings found"
        exit 1
      fi
    # Check trailing whitespace
    - |
      if find src -name "*.ad[sb]" -exec grep -l ' $' {} \; > trailing.txt && [ -s trailing.txt ]; then
        echo "‚ö†Ô∏è  Warning: Trailing whitespace found"
        cat trailing.txt
      fi
    - echo "‚úÖ Formatting check passed"
  allow_failure: false

lint:lines:
  extends: .gnat_base
  stage: lint
  script:
    - echo "üìè Checking line lengths..."
    - |
      for file in src/*.ad[sb]; do
        long_lines=$(awk 'length > 100 {print NR": "$0}' "$file")
        if [ -n "$long_lines" ]; then
          echo "‚ö†Ô∏è  Long lines in $file:"
          echo "$long_lines"
        fi
      done
    - echo "‚úÖ Line length check complete"
  allow_failure: true

# ============================================================================
# BUILD STAGE - Multiple Configurations
# ============================================================================

build:debug:
  extends: 
    - .gnat_base
    - .cache_template
  stage: build
  script:
    - echo "üî® Building debug version..."
    - gprbuild -P tree_navigator.gpr -j0
    - ls -lah bin/
    - file bin/main
    - ./bin/main --version
    - echo "‚úÖ Debug build complete"
  artifacts:
    name: "tree-navigator-debug-${CI_COMMIT_SHORT_SHA}"
    paths:
      - bin/main
      - obj/
    expire_in: 1 day
  needs: []

build:release:
  extends: 
    - .gnat_base
    - .cache_template
  stage: build
  script:
    - echo "üî® Building release version..."
    - gprbuild -P tree_navigator.gpr -XBuild_Mode=release -j0
    - strip bin/main
    - ls -lah bin/
    - file bin/main
    - ./bin/main --version
    - echo "‚úÖ Release build complete"
  artifacts:
    name: "tree-navigator-release-${CI_COMMIT_SHORT_SHA}"
    paths:
      - bin/main
    expire_in: 30 days
  needs: []
  only:
    - main
    - tags
    - merge_requests

build:coverage:
  extends: 
    - .gnat_base
    - .cache_template
  stage: build
  script:
    - echo "üî® Building with coverage instrumentation..."
    - apt-get install -y -qq gcovr
    - gprbuild -P tree_navigator.gpr -cargs -fprofile-arcs -ftest-coverage
    - echo "‚úÖ Coverage build complete"
  artifacts:
    paths:
      - bin/main
      - obj/
    expire_in: 1 day
  needs: []
  only:
    - main
    - merge_requests

# ============================================================================
# TEST STAGE - Comprehensive Testing
# ============================================================================

test:unit:
  extends: .gnat_base
  stage: test
  dependencies:
    - build:debug
  script:
    - echo "üß™ Running unit tests..."
    # Create test structure
    - mkdir -p test_data/{src,obj,bin,docs}
    - touch test_data/src/{main.adb,config.ads}
    - touch test_data/docs/README.md
    - touch test_data/.hidden
    - echo "#!/bin/bash" > test_data/build.sh
    - chmod +x test_data/build.sh
    
    # Basic functionality
    - ./bin/main --version
    - ./bin/main --help
    
    - echo "‚úÖ Unit tests passed"
  artifacts:
    when: always
    expire_in: 1 week

test:functional:
  extends: .gnat_base
  stage: test
  dependencies:
    - build:debug
  script:
    - echo "üß™ Running functional tests..."
    - mkdir -p test_project/{src,obj,bin,docs}
    - touch test_project/src/{main.adb,config.ads,utils.adb}
    - touch test_project/docs/README.md
    - touch test_project/.hidden_file
    - echo "#!/bin/bash" > test_project/build.sh
    - chmod +x test_project/build.sh
    
    # Test 1: Basic export
    - echo "Test 1: Basic export"
    - ./bin/main --export test1.txt --dir test_project
    - test -f test1.txt || exit 1
    
    # Test 2: Depth limiting
    - echo "Test 2: Depth limiting"
    - ./bin/main --export test2.txt --dir test_project --max-depth 1
    - test -f test2.txt || exit 1
    
    # Test 3: Directory exclusion
    - echo "Test 3: Directory exclusion"
    - ./bin/main --export test3.txt --dir test_project --exclude-dirs obj,bin
    - test -f test3.txt || exit 1
    - '! grep -q "obj" test3.txt || exit 1'
    
    # Test 4: File exclusion
    - echo "Test 4: File exclusion"
    - ./bin/main --export test4.txt --dir test_project --exclude-files "*.adb"
    - test -f test4.txt || exit 1
    
    # Test 5: Hidden files
    - echo "Test 5: Hidden files"
    - ./bin/main --export test5.txt --dir test_project --show-hidden
    - test -f test5.txt || exit 1
    
    # Test 6: Type filtering
    - echo "Test 6: Type filtering"
    - ./bin/main --export test6.txt --dir test_project --only-type executable
    - test -f test6.txt || exit 1
    
    # Test 7: Size display
    - echo "Test 7: Size display"
    - ./bin/main --export test7.txt --dir test_project --show-size
    - test -f test7.txt || exit 1
    - grep -q "bytes" test7.txt || exit 1
    
    - echo "‚úÖ All functional tests passed"
  artifacts:
    paths:
      - test*.txt
    when: always
    expire_in: 1 week

test:integration:
  extends: .gnat_base
  stage: test
  dependencies:
    - build:debug
  script:
    - echo "üß™ Running integration tests..."
    # Create large test structure
    - |
      mkdir -p large_test
      for i in {1..10}; do
        mkdir -p large_test/dir_$i
        for j in {1..10}; do
          echo "content" > large_test/dir_$i/file_$j.txt
        done
      done
    
    # Test on large structure
    - ./bin/main --export integration.txt --dir large_test --max-depth 3
    - test -f integration.txt || exit 1
    - grep -q "large_test" integration.txt || exit 1
    
    - echo "‚úÖ Integration tests passed"
  artifacts:
    paths:
      - integration.txt
    when: always
    expire_in: 1 week

test:coverage:
  extends: .gnat_base
  stage: test
  dependencies:
    - build:coverage
  script:
    - echo "üìä Generating coverage report..."
    - apt-get install -y -qq gcovr
    
    # Run tests with coverage
    - ./bin/main --export coverage-test.txt --max-depth 3
    
    # Generate coverage reports
    - gcovr --root . --html --html-details -o coverage.html
    - gcovr --root . --xml -o coverage.xml
    - gcovr --root . --print-summary
    
    - echo "‚úÖ Coverage report generated"
  coverage: '/lines: \d+\.\d+%/'
  artifacts:
    paths:
      - coverage.html
      - coverage.xml
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    expire_in: 30 days
  only:
    - main
    - merge_requests

# ============================================================================
# SECURITY STAGE - Vulnerability Scanning
# ============================================================================

security:sast:
  stage: security
  image: registry.gitlab.com/gitlab-org/security-products/analyzers/semgrep:latest
  script:
    - /analyzer run
  artifacts:
    reports:
      sast: gl-sast-report.json
  allow_failure: true
  only:
    - main
    - merge_requests

security:container:
  extends: .docker_base
  stage: security
  dependencies:
    - build:release
  script:
    - echo "üîí Scanning container for vulnerabilities..."
    - docker build -t tree-navigator:${CI_COMMIT_SHORT_SHA} .
    - |
      docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
        aquasec/trivy image --severity HIGH,CRITICAL \
        tree-navigator:${CI_COMMIT_SHORT_SHA}
    - echo "‚úÖ Container scan complete"
  allow_failure: true
  only:
    - main
    - merge_requests

security:dependency:
  stage: security
  image: registry.gitlab.com/gitlab-org/security-products/analyzers/gemnasium:latest
  script:
    - /analyzer run
  artifacts:
    reports:
      dependency_scanning: gl-dependency-scanning-report.json
  allow_failure: true
  only:
    - main
    - merge_requests

# ============================================================================
# PERFORMANCE STAGE - Benchmarking
# ============================================================================

performance:benchmark:
  extends: .gnat_base
  stage: performance
  dependencies:
    - build:release
  script:
    - echo "‚ö° Running performance benchmarks..."
    - apt-get install -y -qq time bc
    
    # Create large test structure
    - |
      mkdir -p perf_test
      for i in {1..100}; do
        mkdir -p perf_test/dir_$i
        for j in {1..50}; do
          echo "content" > perf_test/dir_$i/file_$j.txt
        done
      done
    
    # Benchmark export
    - echo "Testing export performance..."
    - /usr/bin/time -v ./bin/main --export perf.txt --dir perf_test 2>&1 | tee benchmark.txt
    
    # Extract metrics
    - |
      echo "Performance Metrics:"
      grep "Maximum resident set size" benchmark.txt || true
      grep "Elapsed (wall clock) time" benchmark.txt || true
      grep "CPU usage" benchmark.txt || true
    
    - echo "‚úÖ Benchmark complete"
  artifacts:
    paths:
      - benchmark.txt
      - perf.txt
    expire_in: 30 days
  only:
    - main
    - tags

performance:load:
  extends: .gnat_base
  stage: performance
  dependencies:
    - build:release
  script:
    - echo "‚ö° Running load tests..."
    
    # Create very large structure
    - |
      mkdir -p load_test
      for i in {1..200}; do
        mkdir -p load_test/dir_$i
        for j in {1..100}; do
          echo "content" > load_test/dir_$i/file_$j.txt
        done
      done
    
    # Stress test
    - echo "Running stress test..."
    - time ./bin/main --export load.txt --dir load_test --max-depth 5
    
    - echo "‚úÖ Load test complete"
  artifacts:
    paths:
      - load.txt
    expire_in: 7 days
  allow_failure: true
  only:
    - main

# ============================================================================
# PACKAGE STAGE - Build Distributions
# ============================================================================

package:deb:
  extends: .gnat_base
  stage: package
  dependencies:
    - build:release
  script:
    - echo "üì¶ Creating DEB package..."
    - apt-get install -y -qq dpkg-dev
    - VERSION=${CI_COMMIT_TAG:-${CI_COMMIT_SHORT_SHA}}
    
    # Create package structure
    - mkdir -p package/DEBIAN
    - mkdir -p package/usr/local/bin
    - mkdir -p package/usr/local/share/man/man1
    - mkdir -p package/usr/share/doc/tree-navigator
    
    # Copy files
    - cp bin/main package/usr/local/bin/tree-navigator
    - cp man/tree-navigator.1 package/usr/local/share/man/man1/
    - cp README.md LICENSE CHANGELOG.md package/usr/share/doc/tree-navigator/
    
    # Create control file
    - |
      cat > package/DEBIAN/control << CTRL
      Package: tree-navigator
      Version: ${VERSION}
      Section: utils
      Priority: optional
      Architecture: amd64
      Maintainer: Tree Navigator Contributors <team@tree-navigator.io>
      Description: Type-safe directory tree visualization tool
       A powerful directory tree export and navigation tool with
       extensive filtering capabilities, built with Ada 2022.
       .
       Features:
        - Smart directory and file filtering
        - Type-based file selection
        - Export to files for documentation
        - Interactive navigation mode
        - Bookmark support
      CTRL
    
    # Build package
    - dpkg-deb --build package tree-navigator_${VERSION}_amd64.deb
    - dpkg-deb --info tree-navigator_${VERSION}_amd64.deb
    
    - echo "‚úÖ DEB package created"
  artifacts:
    name: "tree-navigator-deb-${CI_COMMIT_REF_NAME}"
    paths:
      - tree-navigator_*.deb
    expire_in: 90 days
  only:
    - main
    - tags

package:rpm:
  extends: .gnat_base
  stage: package
  dependencies:
    - build:release
  script:
    - echo "üì¶ Creating RPM package..."
    - apt-get install -y -qq rpm
    - VERSION=${CI_COMMIT_TAG:-${CI_COMMIT_SHORT_SHA}}
    
    # Create RPM structure
    - mkdir -p ~/rpmbuild/{BUILD,RPMS,SOURCES,SPECS,SRPMS}
    
    # Create spec file
    - |
      cat > ~/rpmbuild/SPECS/tree-navigator.spec << SPEC
      Name:           tree-navigator
      Version:        ${VERSION}
      Release:        1%{?dist}
      Summary:        Type-safe directory tree visualization tool
      License:        MIT
      BuildArch:      x86_64

      %description
      A powerful directory tree export and navigation tool with
      extensive filtering capabilities, built with Ada 2022.

      %install
      mkdir -p %{buildroot}/usr/local/bin
      mkdir -p %{buildroot}/usr/local/share/man/man1
      cp ${CI_PROJECT_DIR}/bin/main %{buildroot}/usr/local/bin/tree-navigator
      cp ${CI_PROJECT_DIR}/man/tree-navigator.1 %{buildroot}/usr/local/share/man/man1/

      %files
      /usr/local/bin/tree-navigator
      /usr/local/share/man/man1/tree-navigator.1

      %changelog
      * $(date +"%a %b %d %Y") CI Build <ci@tree-navigator.io> - ${VERSION}-1
      - Automated build from CI/CD
      SPEC
    
    # Build RPM
    - rpmbuild -bb ~/rpmbuild/SPECS/tree-navigator.spec
    - cp ~/rpmbuild/RPMS/x86_64/*.rpm .
    
    - echo "‚úÖ RPM package created"
  artifacts:
    name: "tree-navigator-rpm-${CI_COMMIT_REF_NAME}"
    paths:
      - "*.rpm"
    expire_in: 90 days
  only:
    - main
    - tags

package:tarball:
  extends: .gnat_base
  stage: package
  dependencies:
    - build:release
  script:
    - echo "üì¶ Creating tarball..."
    - VERSION=${CI_COMMIT_TAG:-${CI_COMMIT_SHORT_SHA}}
    
    # Create distribution directory
    - mkdir -p tree-navigator-${VERSION}
    - cp bin/main tree-navigator-${VERSION}/tree-navigator
    - cp README.md LICENSE CHANGELOG.md CONTRIBUTING.md tree-navigator-${VERSION}/
    - cp -r man tree-navigator-${VERSION}/
    
    # Create tarball
    - tar czf tree-navigator-${VERSION}-linux-x86_64.tar.gz tree-navigator-${VERSION}
    - tar czf tree-navigator-${VERSION}-source.tar.gz --exclude=obj --exclude=bin .
    
    # Create checksums
    - sha256sum tree-navigator-*.tar.gz > checksums.txt
    
    - echo "‚úÖ Tarballs created"
  artifacts:
    name: "tree-navigator-tarball-${CI_COMMIT_REF_NAME}"
    paths:
      - tree-navigator-*.tar.gz
      - checksums.txt
    expire_in: 90 days
  only:
    - main
    - tags

package:docker:
  extends: .docker_base
  stage: package
  dependencies:
    - build:release
  script:
    - echo "üê≥ Building Docker image..."
    - docker build -t ${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA} .
    - docker build -t ${CI_REGISTRY_IMAGE}:latest .
    
    # Tag for registry
    - docker tag ${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA} ${CI_REGISTRY_IMAGE}:${CI_COMMIT_REF_SLUG}
    
    # Login and push
    - echo ${CI_REGISTRY_PASSWORD} | docker login -u ${CI_REGISTRY_USER} --password-stdin ${CI_REGISTRY}
    - docker push ${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA}
    - docker push ${CI_REGISTRY_IMAGE}:${CI_COMMIT_REF_SLUG}
    
    # Push latest on main
    - |
      if [ "${CI_COMMIT_BRANCH}" == "main" ]; then
        docker push ${CI_REGISTRY_IMAGE}:latest
      fi
    
    - echo "‚úÖ Docker image pushed"
  only:
    - main
    - tags
    - merge_requests

# ============================================================================
# DEPLOY STAGE - Multi-Environment Deployment
# ============================================================================

.deploy_base:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache curl bash

deploy:staging:
  extends: .deploy_base
  environment:
    name: staging
    url: https://staging.tree-navigator.io
  script:
    - echo "üöÄ Deploying to staging..."
    - echo "Docker image: ${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA}"
    
    # Deploy to Kubernetes staging
    - |
      if [ -n "${KUBECONFIG_STAGING}" ]; then
        apk add --no-cache kubectl
        echo "${KUBECONFIG_STAGING}" > /tmp/kubeconfig
        export KUBECONFIG=/tmp/kubeconfig
        kubectl set image deployment/tree-navigator \
          tree-navigator=${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA} \
          -n staging
        kubectl rollout status deployment/tree-navigator -n staging
      fi
    
    - echo "‚úÖ Deployed to staging"
  only:
    - main
  when: manual

deploy:production:
  extends: .deploy_base
  environment:
    name: production
    url: https://tree-navigator.io
  script:
    - echo "üöÄ Deploying to production..."
    - echo "Docker image: ${CI_REGISTRY_IMAGE}:${CI_COMMIT_TAG}"
    
    # Deploy to Kubernetes production
    - |
      if [ -n "${KUBECONFIG_PRODUCTION}" ]; then
        apk add --no-cache kubectl
        echo "${KUBECONFIG_PRODUCTION}" > /tmp/kubeconfig
        export KUBECONFIG=/tmp/kubeconfig
        kubectl set image deployment/tree-navigator \
          tree-navigator=${CI_REGISTRY_IMAGE}:${CI_COMMIT_TAG} \
          -n production
        kubectl rollout status deployment/tree-navigator -n production
      fi
    
    - echo "‚úÖ Deployed to production"
  only:
    - tags
  when: manual

deploy:pages:
  stage: deploy
  dependencies:
    - test:coverage
  script:
    - echo "üìÑ Deploying documentation to GitLab Pages..."
    - mkdir -p public
    - cp coverage.html public/index.html
    - cp -r docs/* public/ 2>/dev/null || true
    - echo "‚úÖ Documentation deployed"
  artifacts:
    paths:
      - public
    expire_in: 30 days
  only:
    - main

# ============================================================================
# MONITORING STAGE - Post-Deployment Checks
# ============================================================================

monitoring:health_check:
  stage: monitoring
  image: curlimages/curl:latest
  script:
    - echo "üè• Running health checks..."
    - |
      if [ -n "${STAGING_URL}" ]; then
        echo "Checking staging..."
        curl -f ${STAGING_URL}/health || echo "‚ö†Ô∏è  Staging health check failed"
      fi
    - echo "‚úÖ Health checks complete"
  needs:
    - deploy:staging
  only:
    - main
  allow_failure: true

monitoring:smoke_test:
  extends: .gnat_base
  stage: monitoring
  dependencies:
    - package:tarball
  script:
    - echo "üí® Running smoke tests on packaged binary..."
    - tar xzf tree-navigator-*-linux-x86_64.tar.gz
    - cd tree-navigator-*
    - ./tree-navigator --version
    - ./tree-navigator --help
    - ./tree-navigator --export smoke-test.txt --max-depth 2
    - test -f smoke-test.txt || exit 1
    - echo "‚úÖ Smoke tests passed"
  needs:
    - package:tarball
  only:
    - main
    - tags

# ============================================================================
# SCHEDULED JOBS
# ============================================================================

nightly:build:
  extends: 
    - .gnat_base
    - .cache_template
  stage: build
  script:
    - echo "üåô Running nightly build..."
    - gprbuild -P tree_navigator.gpr -j0
    - ./bin/main --export nightly-test.txt --max-depth 5
    - echo "‚úÖ Nightly build complete"
  artifacts:
    name: "nightly-${CI_COMMIT_SHORT_SHA}"
    paths:
      - bin/main
      - nightly-test.txt
    expire_in: 7 days
  only:
    - schedules

dependency:audit:
  extends: .gnat_base
  stage: security
  script:
    - echo "üîç Auditing dependencies..."
    - apt-cache policy gnat-${GNAT_VERSION}
    - gprbuild --version
    - echo "‚úÖ Dependency audit complete"
  only:
    - schedules
  allow_failure: true

# ============================================================================
# WORKFLOW RULES
# ============================================================================

workflow:
  rules:
    # Run pipeline for merge requests
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    # Run pipeline for tags
    - if: '$CI_COMMIT_TAG'
    # Run pipeline for main branch
    - if: '$CI_COMMIT_BRANCH == "main"'
    # Run scheduled pipelines
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
    # Don't run for other branches by default
    - when: never
